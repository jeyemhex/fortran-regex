!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
$$	example_regex.c	/^    $$ = frag(s, append($1.out, $3.out));$/;"	m	union:concat	file:
$1	example_regex.c	/^    $1 = paren($1, 0);$/;"	m	union:EOL	file:
EOL	example_regex.c	/^line: alt EOL$/;"	u	file:
add_state	regex.f90	/^      recursive subroutine add_state(/;"	s	function:run_nfa_fast
addstate	example_regex.c	/^void addstate(List *l, State *s, Sub *m, char *p) {$/;"	f
allocate_nfa	regex.f90	/^    subroutine allocate_nfa(/;"	s	module:regex
alpha_ch	regex.f90	/^  integer,  parameter ::  alpha_ch /;"	v	module:regex
any_ch	regex.f90	/^  integer,  parameter ::  any_ch /;"	v	module:regex
append	regex.f90	/^    function append(/;"	f	module:regex
c	example_regex.c	/^  int  c;$/;"	m	union:__anon1	file:
c	regex.f90	/^    integer               ::  c$/;"	k	type:state
cat_op	regex.f90	/^  integer,  parameter ::  cat_op /;"	v	module:regex
close_par_op	regex.f90	/^  integer,  parameter ::  close_par_op /;"	v	module:regex
concat	example_regex.c	/^|  alt '|' concat$/;"	u	file:
deallocate_list	regex.f90	/^    subroutine deallocate_list(/;"	s	module:regex
deallocate_nfa	regex.f90	/^    subroutine deallocate_nfa(/;"	s	module:regex
dump	example_regex.c	/^void dump(State *s) {$/;"	f
dumplist	example_regex.c	/^void dumplist(List *l) {$/;"	f
elem	regex.f90	/^    type(frag), pointer ::  elem$/;"	k	type:frag_stack
failed	re_test.f90	/^  character(len=120)  ::  failed(/;"	v	program:re_test
finish_ch	regex.f90	/^  integer,  parameter ::  finish_ch /;"	v	module:regex
frag	example_regex.c	/^  Frag  frag;$/;"	m	union:__anon1	file:
frag	regex.f90	/^  type  :: frag$/;"	t	module:regex
frag_stack	regex.f90	/^  type  :: frag_stack$/;"	t	module:regex
head	regex.f90	/^    type(state),    pointer :: head$/;"	k	type:nfa_type
i	re_test.f90	/^  in/;"	v	program:re_test
ifail	re_test.f90	/^  integer ::  ifail,/;"	v	program:re_test
input	example_regex.c	/^char *input;$/;"	v
is_match	regex.f90	/^      function is_match(/;"	f	function:run_nfa_fast
last_list	regex.f90	/^    integer               ::  last_list$/;"	k	type:state
list	regex.f90	/^    type  ::  list$/;"	t	function:run_nfa_fast
longer	example_regex.c	/^int longer(Sub *a, Sub *b) {$/;"	f
main	example_regex.c	/^int main(int argc, char **argv) {$/;"	f
match	example_regex.c	/^int match(State *start, char *p, Sub *m) {$/;"	f
match_st	regex.f90	/^  integer,  parameter ::  match_st /;"	v	module:regex
n_alpha_ch	regex.f90	/^  integer,  parameter ::  n_alpha_ch /;"	v	module:regex
n_alt	regex.f90	/^    integer ::  n_alt$/;"	k	type:paren_list
n_atom	regex.f90	/^    integer ::  n_atom$/;"	k	type:paren_list
n_numeric_ch	regex.f90	/^  integer,  parameter ::  n_numeric_ch /;"	v	module:regex
n_space_ch	regex.f90	/^  integer,  parameter ::  n_space_ch /;"	v	module:regex
n_states	regex.f90	/^    integer                 :: n_states$/;"	k	type:nfa_type
n_word_ch	regex.f90	/^  integer,  parameter ::  n_word_ch /;"	v	module:regex
new_frag	regex.f90	/^      function new_frag(/;"	f	function:pf_to_nfa
new_list	regex.f90	/^    function new_list(/;"	f	module:regex
new_state	regex.f90	/^      function new_state(/;"	f	function:pf_to_nfa
next	regex.f90	/^    type(ptr_list), pointer ::  next /;"	k	type:ptr_list
nfa_max_print	regex.f90	/^  integer,  parameter ::  nfa_max_print /;"	v	module:regex
nfa_type	regex.f90	/^  type, public :: nfa_type$/;"	t	module:regex
nfails	re_test.f90	/^  integer ::  ifail, nfails,/;"	v	program:re_test
nparen	example_regex.c	/^  int nparen;$/;"	m	union:__anon1	file:
ntests	re_test.f90	/^  integer ::  ifail, nfails, ntests,/;"	v	program:re_test
null_st	regex.f90	/^  integer,  parameter ::  null_st /;"	v	module:regex
numeric_ch	regex.f90	/^  integer,  parameter ::  numeric_ch /;"	v	module:regex
open_par_op	regex.f90	/^  integer,  parameter ::  open_par_op /;"	v	module:regex
or_op	regex.f90	/^  integer,  parameter ::  or_op /;"	v	module:regex
out1	regex.f90	/^    type(ptr_list), pointer ::  out1 /;"	k	type:frag
out1	regex.f90	/^    type(state),  pointer ::  out1 /;"	k	type:state
out2	regex.f90	/^    type(state),  pointer ::  out2 /;"	k	type:state
paren_list	regex.f90	/^  type  ::  paren_list$/;"	t	module:regex
patch	regex.f90	/^    subroutine patch(/;"	s	module:regex
pf_buff_size	regex.f90	/^  integer,  parameter ::  pf_buff_size /;"	v	module:regex
pf_stack_size	regex.f90	/^  integer,  parameter ::  pf_stack_size /;"	v	module:regex
pf_to_nfa	regex.f90	/^    function pf_to_nfa(/;"	f	module:regex
plus_op	regex.f90	/^  integer,  parameter ::  plus_op /;"	v	module:regex
pop	regex.f90	/^      function pop(/;"	f	function:pf_to_nfa
print_failures	re_test.f90	/^  subroutine print_failures(/;"	s	program:re_test
print_pf	regex.f90	/^    subroutine print_pf(/;"	s	module:regex
print_state	regex.f90	/^    recursive subroutine print_state(/;"	s	module:regex
printmatch	example_regex.c	/^void printmatch(Sub *m, int n) {$/;"	f
ptr_list	regex.f90	/^  type  :: ptr_list$/;"	t	module:regex
push	regex.f90	/^      subroutine push(/;"	s	function:pf_to_nfa
quest_op	regex.f90	/^  integer,  parameter ::  quest_op /;"	v	module:regex
re	re_check.f90	/^  character(len=100) :: str, re$/;"	v	program:re_check
re_check	re_check.f90	/^program re_check$/;"	p
re_match	regex.f90	/^    function re_match(/;"	f	module:regex
re_match_str	regex.f90	/^    function re_match_str(/;"	f	module:regex
re_split	regex.f90	/^    subroutine re_split(/;"	s	module:regex
re_test	re_test.f90	/^program re_test$/;"	p
re_to_pf	regex.f90	/^    function re_to_pf(/;"	f	module:regex
regex	regex.f90	/^module regex$/;"	m
run_nfa_fast	regex.f90	/^    function run_nfa_fast(/;"	f	module:regex
run_nfa_full	regex.f90	/^    recursive function run_nfa_full(/;"	f	module:regex
s	example_regex.c	/^    State *s = state(Split, 0, $1.start, $3.start);$/;"	m	union:concat	file:
s	example_regex.c	/^    State *s;$/;"	m	union:EOL	file:
s	example_regex.c	/^    s = state(Match, 0, NULL, NULL);$/;"	m	union:EOL	file:
s	regex.f90	/^      type(st/;"	k	type:list
s	regex.f90	/^    type(st/;"	k	type:ptr_list
side	regex.f90	/^    integer                 ::  side /;"	k	type:ptr_list
space_ch	regex.f90	/^  integer,  parameter ::  space_ch /;"	v	module:regex
split_st	regex.f90	/^  integer,  parameter ::  split_st /;"	v	module:regex
star_op	regex.f90	/^  integer,  parameter ::  star_op /;"	v	module:regex
start	example_regex.c	/^    start = $1.start;$/;"	m	union:EOL	file:
start	regex.f90	/^    type(state),    pointer ::  start /;"	k	type:frag
start_ch	regex.f90	/^  integer,  parameter ::  start_ch /;"	v	module:regex
start_list	regex.f90	/^      function start_list(/;"	f	function:run_nfa_fast
startlist	example_regex.c	/^List* startlist(State *start, char *p, List *l) {$/;"	f
state	regex.f90	/^  type, public  :: state$/;"	t	module:regex
states	regex.f90	/^    type(ptr_list), pointer :: states$/;"	k	type:nfa_type
step	example_regex.c	/^void step(List *clist, int c, char *p, List *nlist, Sub *match) {$/;"	f
step	regex.f90	/^      recursive subroutine step(/;"	s	function:run_nfa_full
step	regex.f90	/^      subroutine step(/;"	s	function:run_nfa_fast
str	re_check.f90	/^  character(len=100) :: str,/;"	v	program:re_check
test	re_test.f90	/^  subroutine test(/;"	s	program:re_test
text	example_regex.c	/^char *text;$/;"	v
word_ch	regex.f90	/^  integer,  parameter ::  word_ch /;"	v	module:regex
yyerror	example_regex.c	/^void yyerror(char *s) {$/;"	f
yylex	example_regex.c	/^int yylex(void) {$/;"	f
