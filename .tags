!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
900	regex.f90	/^900 continue$/;"	l	function:run_nfa	file:
901	regex.f90	/^901 continue$/;"	l	function:re_match	file:
902	regex.f90	/^902 continue$/;"	l	function:re_match_str	file:
add_state	regex.f90	/^    recursive subroutine add_state(/;"	s	function:run_nfa
alpha_ch	regex.f90	/^  integer,  parameter ::  alpha_ch /;"	v	module:regex
any_ch	regex.f90	/^  integer,  parameter ::  any_ch /;"	v	module:regex
append	regex.f90	/^  function append(/;"	f	module:regex
c	regex.f90	/^    integer               ::  c$/;"	k	type:state
cat_op	regex.f90	/^  integer,  parameter ::  cat_op /;"	v	module:regex
deallocate_list	regex.f90	/^  subroutine deallocate_list(/;"	s	module:regex
elem	regex.f90	/^    type(frag), pointer ::  elem$/;"	k	type:frag_stack
failed	re_test.f90	/^  character(len=120)  ::  failed(/;"	v	program:re_test
finish_ch	regex.f90	/^  integer,  parameter ::  finish_ch /;"	v	module:regex
frag	regex.f90	/^  type  :: frag$/;"	t	module:regex
frag_stack	regex.f90	/^  type  :: frag_stack$/;"	t	module:regex
head	regex.f90	/^    logical               ::  head /;"	k	type:state
ifail	re_test.f90	/^  integer ::  ifail,/;"	v	program:re_test
is_match	regex.f90	/^    function is_match(/;"	f	function:run_nfa
last_list	regex.f90	/^    integer               ::  last_list$/;"	k	type:state
list	regex.f90	/^    type  ::  list$/;"	t	function:run_nfa
match_st	regex.f90	/^  integer,  parameter ::  match_st /;"	v	module:regex
n_alpha_ch	regex.f90	/^  integer,  parameter ::  n_alpha_ch /;"	v	module:regex
n_alt	regex.f90	/^    integer ::  n_alt$/;"	k	type:paren_list
n_atom	regex.f90	/^    integer ::  n_atom$/;"	k	type:paren_list
n_numeric_ch	regex.f90	/^  integer,  parameter ::  n_numeric_ch /;"	v	module:regex
n_space_ch	regex.f90	/^  integer,  parameter ::  n_space_ch /;"	v	module:regex
n_states	regex.f90	/^  integer :: n_states$/;"	v	module:regex
n_word_ch	regex.f90	/^  integer,  parameter ::  n_word_ch /;"	v	module:regex
new_frag	regex.f90	/^  function new_frag(/;"	f	module:regex
new_list	regex.f90	/^  function new_list(/;"	f	module:regex
new_state	regex.f90	/^    function new_state(/;"	f	function:post_to_nfa
next	regex.f90	/^    type(ptr_list), pointer ::  next /;"	k	type:ptr_list
nfails	re_test.f90	/^  integer ::  ifail, nfails,/;"	v	program:re_test
ntests	re_test.f90	/^  integer ::  ifail, nfails, ntests$/;"	v	program:re_test
null_st	regex.f90	/^  integer,  parameter ::  null_st /;"	v	module:regex
numeric_ch	regex.f90	/^  integer,  parameter ::  numeric_ch /;"	v	module:regex
or_op	regex.f90	/^  integer,  parameter ::  or_op /;"	v	module:regex
out1	regex.f90	/^    type(ptr_list), pointer ::  out1 /;"	k	type:frag
out1	regex.f90	/^    type(state),  pointer ::  out1 /;"	k	type:state
out2	regex.f90	/^    type(state),  pointer ::  out2 /;"	k	type:state
paren_list	regex.f90	/^  type  ::  paren_list$/;"	t	module:regex
patch	regex.f90	/^  subroutine patch(/;"	s	module:regex
pf_buff_size	regex.f90	/^  integer,  parameter ::  pf_buff_size /;"	v	module:regex
plus_op	regex.f90	/^  integer,  parameter ::  plus_op /;"	v	module:regex
pop	regex.f90	/^    function pop(/;"	f	function:post_to_nfa
post_to_nfa	regex.f90	/^  function post_to_nfa(/;"	f	module:regex
print_failures	re_test.f90	/^  subroutine print_failures(/;"	s	program:re_test
print_pf	regex.f90	/^  subroutine print_pf(/;"	s	module:regex
print_state	regex.f90	/^  recursive subroutine print_state(/;"	s	module:regex
ptr_list	regex.f90	/^  type  :: ptr_list$/;"	t	module:regex
push	regex.f90	/^    subroutine push(/;"	s	function:post_to_nfa
quest_op	regex.f90	/^  integer,  parameter ::  quest_op /;"	v	module:regex
re_match	regex.f90	/^  function re_match(/;"	f	module:regex
re_match_str	regex.f90	/^  function re_match_str(/;"	f	module:regex
re_test	re_test.f90	/^program re_test$/;"	p
re_to_post	regex.f90	/^  function re_to_post(/;"	f	module:regex
regex	regex.f90	/^module regex$/;"	m
run_nfa	regex.f90	/^  function run_nfa(/;"	f	module:regex
s	regex.f90	/^      type(st/;"	k	type:list
s	regex.f90	/^    type(st/;"	k	type:ptr_list
side	regex.f90	/^    integer                 ::  side /;"	k	type:ptr_list
space_ch	regex.f90	/^  integer,  parameter ::  space_ch /;"	v	module:regex
split_st	regex.f90	/^  integer,  parameter ::  split_st /;"	v	module:regex
star_op	regex.f90	/^  integer,  parameter ::  star_op /;"	v	module:regex
start	regex.f90	/^    type(state),    pointer ::  start /;"	k	type:frag
start_ch	regex.f90	/^  integer,  parameter ::  start_ch /;"	v	module:regex
start_list	regex.f90	/^    function start_list(/;"	f	function:run_nfa
state	regex.f90	/^  type, public  :: state$/;"	t	module:regex
step	regex.f90	/^    subroutine step(/;"	s	function:run_nfa
test	re_test.f90	/^  subroutine test(/;"	s	program:re_test
word_ch	regex.f90	/^  integer,  parameter ::  word_ch /;"	v	module:regex
